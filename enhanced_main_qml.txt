/*
 * Enhanced main.qml with Atmospheric Effects Integration
 * Original Copyright 2015 Martin Kotelnik <clearmartin@seznam.cz>
 * Atmospheric Effects Enhancement
 */
import QtQuick 2.15
import QtQuick.Layouts
import org.kde.plasma.plasmoid
import org.kde.plasma.core as PlasmaCore
import QtQuick.Controls
import org.kde.plasma.components 3.0 as PlasmaComponents
import org.kde.plasma.plasma5support as Plasma5Support
import org.kde.kirigami as Kirigami
import "providers"
import "../code/data-loader.js" as DataLoader
import "../code/config-utils.js" as ConfigUtils
import "../code/icons.js" as IconTools
import "../code/unit-utils.js" as UnitUtils
import "../code/timezoneData.js" as TZ

PlasmoidItem {
    id: main

    /* Includes */
    WeatherCache {
        id: weatherCache
        cacheId: cacheData.plasmoidCacheId
    }
    Plasma5Support.DataSource {
        id: dataSource
        engine: "time"
        connectedSources: ["Local"]
        interval: 0
    }
    FontLoader {
        source: "../fonts/weathericons-regular-webfont-2.0.11.ttf"
    }
    OpenMeteo {
        id: omProvider
    }
    MetNo {
        id: metnoProvider
    }
    OpenWeatherMap {
        id: owmProvider
    }

    // === ATMOSPHERIC ENHANCEMENT PROPERTIES ===
    property bool atmosphericEffectsEnabled: plasmoid.configuration.atmosphericEffectsEnabled !== false
    property bool dynamicWallpaperEnabled: plasmoid.configuration.dynamicWallpaperEnabled !== false
    property bool soundEffectsEnabled: plasmoid.configuration.soundEffectsEnabled !== false
    property bool particleEffectsEnabled: plasmoid.configuration.particleEffectsEnabled !== false
    property bool feelsLikeTooltipEnabled: plasmoid.configuration.feelsLikeTooltipEnabled !== false
    
    // Wallpaper paths - user configurable
    property string morningWallpaper: plasmoid.configuration.morningWallpaper || "/home/x2/Wallpapers/System-Defaults/fruitdark.jpg"
    property string afternoonWallpaper: plasmoid.configuration.afternoonWallpaper || "/home/x2/Wallpapers/System-Defaults/fruit.jpg"
    property string eveningWallpaper: plasmoid.configuration.eveningWallpaper || "/home/x2/Wallpapers/System-Defaults/fruitdarker.jpg"
    property string nightWallpaper: plasmoid.configuration.nightWallpaper || "/home/x2/Wallpapers/System-Defaults/fruitdarkest.jpg"

    // === ENHANCED WEATHER PROPERTIES ===
    property real feelsLikeTemp: {
        if (!currentWeatherModel || currentWeatherModel.temperature === undefined) return 0
        
        var temp = currentWeatherModel.temperature
        var windSpeed = actualWeatherModel.count > 0 ? actualWeatherModel.get(0).windSpeedMps || 0 : 0
        var humidity = currentWeatherModel.humidity || 0

        // Wind chill calculation (if temp < 10°C and wind > 3km/h)
        var windChill = temp
        if (temp <= 10 && windSpeed > 0.83) { // 3km/h ≈ 0.83m/s
            windChill = 13.12 + 0.6215 * temp - 11.37 * Math.pow(windSpeed, 0.16) + 0.3965 * temp * Math.pow(windSpeed, 0.16)
        }

        // Humidity effect (if temp > 15°C)
        var humidityEffect = 0
        if (temp > 15 && humidity > 70) {
            humidityEffect = (humidity - 70) / 10
        }

        return Math.round(windChill + humidityEffect)
    }

    property string comfortLevel: {
        var temp = feelsLikeTemp
        if (temp < 5) return "Freezing"
        else if (temp < 10) return "Cold"
        else if (temp < 15) return "Cool"
        else if (temp < 20) return "Comfortable"
        else if (temp < 25) return "Warm"
        else if (temp < 30) return "Hot"
        else return "Very Hot"
    }

    property string weatherMood: {
        if (!currentWeatherModel) return "Unknown"
        
        var windSpeed = actualWeatherModel.count > 0 ? actualWeatherModel.get(0).windSpeedMps || 0 : 0
        var condition = currentProvider ? currentProvider.currentCondition.toLowerCase() : ""

        if (condition.includes("storm") || condition.includes("thunder")) return "Stormy"
        else if (windSpeed > 15) return "Gusty"
        else if (windSpeed > 8) return "Breezy"
        else if (condition.includes("rain") || condition.includes("drizzle")) return "Wet"
        else if (condition.includes("snow")) return "Snowy"
        else if (condition.includes("cloudy") || condition.includes("overcast")) return "Overcast"
        else return "Calm"
    }

    // === CURRENT WEATHER PROVIDER PROXY ===
    property var currentProvider: {
        if (currentPlace.providerId === "owm") return owmProvider
        else if (currentPlace.providerId === "metno") return metnoProvider
        else if (currentPlace.providerId === "om") return omProvider
        else return null
    }

    // === ORIGINAL PROPERTIES (unchanged) ===
    property bool loadingDataComplete: false

    /* GUI layout stuff */
    property Component fr: FullRepresentation { }
    property Component cr: CompactRepresentation { }
    property Component frInTray: FullRepresentationInTray { }
    property Component crInTray: CompactRepresentationInTray { }

    compactRepresentation: inTray ? crInTray : cr
    fullRepresentation: inTray ? frInTray : fr

    preferredRepresentation: inTray ? undefined : onDesktop ? (desktopMode === 1 ? fullRepresentation : compactRepresentation) : compactRepresentation

    property bool vertical: (plasmoid.formFactor === PlasmaCore.Types.Vertical)
    property bool onDesktop: (plasmoid.location === PlasmaCore.Types.Desktop || plasmoid.location === PlasmaCore.Types.Floating)

    toolTipTextFormat: Text.RichText

    // User Preferences
    property int mgAxisFontSize: plasmoid.configuration.mgAxisFontSize
    property int mgPressureFontSize: plasmoid.configuration.mgPressureFontSize
    property int mgHoursFontSize: plasmoid.configuration.mgHoursFontSize
    property int mgTrailingZeroesFontSize: plasmoid.configuration.mgTrailingZeroesFontSize

    property int hourSpanOm: plasmoid.configuration.hourSpanOm
    property int widgetWidth: plasmoid.configuration.widgetWidth
    property int widgetHeight: plasmoid.configuration.widgetHeight
    property int layoutType: plasmoid.configuration.layoutType
    property int widgetOrder: plasmoid.configuration.widgetOrder
    property int desktopMode: plasmoid.configuration.desktopMode
    property int iconSizeMode: plasmoid.configuration.iconSizeMode
    property int textSizeMode: plasmoid.configuration.textSizeMode
    property bool debugLogging: plasmoid.configuration.debugLogging
    property int inTrayActiveTimeoutSec: plasmoid.configuration.inTrayActiveTimeoutSec
    property string widgetFontName: (plasmoid.configuration.widgetFontName === "") ? Kirigami.Theme.defaultFont : plasmoid.configuration.widgetFontName
    property int widgetFontSize: plasmoid.configuration.widgetFontSize
    property int temperatureType: plasmoid.configuration.temperatureType
    property int timezoneType: plasmoid.configuration.timezoneType
    property int pressureType: plasmoid.configuration.pressureType
    property int windSpeedType: plasmoid.configuration.windSpeedType
    property bool twelveHourClockEnabled: Qt.locale().timeFormat(Locale.ShortFormat).toString().indexOf('AP') > -1
    property bool env_QML_XHR_ALLOW_FILE_READ: plasmoid.configuration.qml_XHR_ALLOW_FILE_READ
    property bool inTray: (plasmoid.containment.containmentType === 129) && ((plasmoid.formFactor === 2) || (plasmoid.formFactor === 3))
    readonly property string placesStr: plasmoid.configuration.places

    // Cache, Last Load Time, Widget Status
    property string fullRepresentationAlias
    property string iconNameStr
    property string temperatureStr
    property bool meteogramModelChanged: false
    property int nextDaysCount

    property var loadingData: ({
                                   loadingDatainProgress: false,
                                   loadingDataTimeoutMs: 15000,
                                   loadingXhrs: [],
                                   loadingError: false,
                                   lastloadingStartTime: 0,
                                   lastloadingSuccessTime: 0,
                                   failedAttemptCount: 0
                               })
    property string lastReloadedText: "⬇ " + i18n("%1 ago", "?? min")

    property var cacheData: ({
                                 plasmoidCacheId: plasmoid.id,
                                 cacheKey: "",
                                 cacheMap: ({})
                             })

    // Current Place Data
    property var currentPlace: ({
                                    alias: "",
                                    identifier: "",
                                    provider: "",
                                    providerId:"",
                                    timezoneID: 0,
                                    timezoneShortName: "",
                                    timezoneOffset: 0,
                                    creditLink: "",
                                    creditLabel: "",
                                    cacheID: "",
                                    nextReload: 0
                                })

    property int placesCount

    property var timerData: ({
                                 reloadIntervalMin: 0,
                                 reloadIntervalMs: 0,
                                 nextReload: 0
                             })

    property bool useOnlineWeatherData: true

    /* Data Models */
    property var currentWeatherModel
    ListModel {
        id: nextDaysModel
    }
    ListModel {
        id: meteogramModel
    }
    ListModel {
        id: actualWeatherModel
    }

    // === ATMOSPHERIC EFFECTS COMPONENTS ===
    
    // Weather Effects Layer
    Item {
        id: weatherEffectsContainer
        anchors.fill: parent
        z: 1000
        visible: atmosphericEffectsEnabled && particleEffectsEnabled

        property real windDirection: actualWeatherModel.count > 0 ? actualWeatherModel.get(0).windDirection || 0 : 0

        // Rain Effect
        Item {
            id: rainContainer
            anchors.fill: parent
            rotation: windDirection - 90
            visible: currentProvider && (
                currentProvider.currentCondition.toLowerCase().includes("rain") ||
                currentProvider.currentCondition.toLowerCase().includes("drizzle")
            )

            ParticleSystem {
                id: rainSystem
                width: parent.width
                height: parent.height
                running: parent.visible

                ImageParticle {
                    source: "qrc:/effects/raindrop.svg"
                    colorVariation: 0.1
                    alpha: 0.7
                    size: 8
                    sizeVariation: 3
                    lifeSpan: 1500
                    velocityFromAngle: 90
                    velocityFromMagnitude: 110
                    velocityVariation: 30
                }

                Emitter {
                    anchors.fill: parent
                    emitRate: 150
                    lifeSpan: 1500
                    lifeSpanVariation: 200
                }
            }
        }

        // Snow Effect
        Item {
            id: snowContainer
            anchors.fill: parent
            rotation: windDirection - 90
            visible: currentProvider && (
                currentProvider.currentCondition.toLowerCase().includes("snow") ||
                currentProvider.currentCondition.toLowerCase().includes("sleet")
            )

            ParticleSystem {
                id: snowSystem
                width: parent.width
                height: parent.height
                running: parent.visible

                ImageParticle {
                    source: "qrc:/effects/snowflake.svg"
                    color: "#ffffff"
                    alpha: 0.9
                    size: 12
                    sizeVariation: 4
                    lifeSpan: 4000
                    velocityFromAngle: 90
                    velocityFromMagnitude: 15
                    velocityVariation: 30
                    rotationSpeed: 100
                    rotationSpeedVariation: 50
                }

                Emitter {
                    anchors.fill: parent
                    emitRate: 60
                    lifeSpan: 4000
                    lifeSpanVariation: 500
                }
            }
        }

        // Day/Night Overlay
        Rectangle {
            id: lightingOverlay
            anchors.fill: parent
            color: "black"
            opacity: 0
            z: 999

            Behavior on opacity {
                NumberAnimation {
                    duration: 3000
                    easing.type: Easing.InOutQuad
                }
            }

            opacity: {
                if (!currentProvider) return 0
                
                var cond = currentProvider.currentCondition.toLowerCase()
                var hour = new Date().getHours()

                if (cond.includes("snow") || cond.includes("sleet")) return 0.5
                else if (cond.includes("rain") || cond.includes("drizzle")) return 0.4
                else if (cond.includes("cloudy") || cond.includes("overcast")) return 0.3
                else if (hour >= 18 || hour < 6) return 0.6
                else return 0.0
            }
        }
    }

    // Wallpaper Controller
    Item {
        id: wallpaperController
        visible: atmosphericEffectsEnabled && dynamicWallpaperEnabled

        property real calculatedBrightness: {
            var hour = new Date().getHours()
            var cond = currentProvider ? currentProvider.currentCondition.toLowerCase() : ""

            // Base brightness by time
            var timeBrightness = 100
            if (hour >= 6 && hour < 12) timeBrightness = 85
            else if (hour >= 12 && hour < 17) timeBrightness = 100
            else if (hour >= 17 && hour < 20) timeBrightness = 75
            else timeBrightness = 40

            // Weather adjustment
            var weatherAdjustment = 0
            if (cond.includes("snow")) weatherAdjustment = 10
            else if (cond.includes("rain") || cond.includes("drizzle")) weatherAdjustment = -15
            else if (cond.includes("cloudy") || cond.includes("overcast")) weatherAdjustment = -20
            else if (cond.includes("clear") || cond.includes("sun")) weatherAdjustment = 5

            return Math.max(20, Math.min(100, timeBrightness + weatherAdjustment))
        }

        property string selectedWallpaper: {
            var hour = new Date().getHours()
            if (hour >= 6 && hour < 12) return morningWallpaper
            else if (hour >= 12 && hour < 17) return afternoonWallpaper
            else if (hour >= 17 && hour < 20) return eveningWallpaper
            else return nightWallpaper
        }

        function applyWallpaperWithBrightness() {
            if (!dynamicWallpaperEnabled) return
            
            var path = selectedWallpaper
            console.log("Applying wallpaper:", path, "brightness:", calculatedBrightness)
            
            // Here you would implement the actual wallpaper setting logic
            // This requires platform-specific implementation
        }

        Component.onCompleted: {
            if (dynamicWallpaperEnabled) {
                applyWallpaperWithBrightness()
                
                // Update every 5 minutes
                Timer {
                    interval: 5 * 60 * 1000
                    repeat: true
                    running: true
                    onTriggered: applyWallpaperWithBrightness()
                }
            }
        }
    }

    // === ORIGINAL EVENT HANDLERS ===
    onLoadingDataCompleteChanged: {
        dbgprint2("loadingDataComplete:" + loadingDataComplete)
    }

    onEnv_QML_XHR_ALLOW_FILE_READChanged: {
        plasmoid.configuration.qml_XHR_ALLOW_FILE_READ = env_QML_XHR_ALLOW_FILE_READ
        dbgprint("QML_XHR_ALLOW_FILE_READ Enabled: " + env_QML_XHR_ALLOW_FILE_READ)
    }

    onPlacesStrChanged: {
        let places = ConfigUtils.getPlacesArray()
        let placesCount = places.length - 1
        let i = Math.min(plasmoid.configuration.placeIndex, placesCount)
        if (currentPlace != places[i].placeAlias) {
            setNextPlace(true)
        }
    }

    // === ORIGINAL FUNCTIONS ===
    function dbgprint(msg) {
        if (!debugLogging) {
            return
        }
        print("[kate weatherWidget] " + msg)
    }

    function dbgprint2(msg) {
        if (!debugLogging) {
            return
        }
        console.log("\n\n")
        console.log("*".repeat(msg.length + 4))
        console.log("* " + msg +" *")
        console.log("*".repeat(msg.length + 4))
    }

    function getLocalTimeZone() {
        return dataSource.data["Local"]["Timezone Abbreviation"]
    }

    function dateNow() {
        var now=new Date().getTime()
        return now
    }

    function setCurrentProviderAccordingId(providerId) {
        currentPlace.providerId = providerId
        if (providerId === "owm") {
            dbgprint("setting provider OpenWeatherMap")
            return owmProvider
        }
        if (providerId === "metno") {
            dbgprint("setting provider metno")
            return metnoProvider
        }
        if (providerId === "om") {
            dbgprint("setting provider OpenMeteo")
            return omProvider
        }
    }

    function emptyWeatherModel() {
        return {
            temperature: -9999,
            iconName: 0,
            windDirection: 0,
            windSpeedMps: 0,
            pressureHpa: 0,
            humidity: 0,
            cloudiness: 0,
            sunRise: new Date("2000-01-01T00:00:00"),
            sunSet: new Date("2000-01-01T00:00:00"),
            sunRiseTime: "0:00",
            sunSetTime: "0:00",
            isDay: false,
            nearFutureWeather: {
                iconName: null,
                temperature: null
            }
        }
    }

    function setNextPlace(initial,direction) {
        if (direction === undefined) {
            direction = "+"
        }
        currentWeatherModel=emptyWeatherModel()
        nextDaysModel.clear()
        meteogramModel.clear()

        var places = ConfigUtils.getPlacesArray()
        placesCount = places.length
        var placeIndex = plasmoid.configuration.placeIndex
        dbgprint("places count=" + placesCount + ", placeIndex=" + plasmoid.configuration.placeIndex)
        if (!initial) {
            (direction === "+") ? placeIndex++ : placeIndex--
        }
        if (placeIndex > places.length - 1) {
            placeIndex = 0
        }
        if (placeIndex < 0 ) {
            placeIndex = places.length - 1
        }
        plasmoid.configuration.placeIndex = placeIndex
        dbgprint("placeIndex now: " + plasmoid.configuration.placeIndex)
        var placeObject = places[placeIndex]

        currentPlace.identifier = placeObject.placeIdentifier
        currentPlace.alias = placeObject.placeAlias
        currentPlace.timezoneID = placeObject.timezoneID
        currentPlace.providerId = placeObject.providerId
        currentPlace.provider = setCurrentProviderAccordingId(placeObject.providerId)

        if (placeObject.timezoneID === undefined) {
            currentPlace.timezoneID = -1
        } else {
            currentPlace.timezoneID = parseInt(placeObject.timezoneID)
        }

        let tzData = TZ.TZData[currentPlace.timezoneID]
        currentPlace.timezoneShortName = "LOCAL"
        if (currentPlace.providerId === "metno") {
            if (TZ.isDST(tzData.DSTData)){
                currentPlace.timezoneShortName = tzData.DSTName
                currentPlace.timezoneOffset = parseInt(tzData.DSTOffset)
            } else {
                currentPlace.timezoneShortName = tzData.TZName
                currentPlace.timezoneOffset = parseInt(tzData.Offset)
            }
        }
        if (currentPlace.providerId === "om") {
            if (TZ.isDST(tzData.DSTData)){
                currentPlace.timezoneShortName = tzData.DSTName
                currentPlace.timezoneOffset = parseInt(tzData.DSTOffset)
            } else {
                currentPlace.timezoneShortName = tzData.TZName
                currentPlace.timezoneOffset = parseInt(tzData.Offset)
            }
        }

        fullRepresentationAlias = currentPlace.alias

        cacheData.cacheKey = DataLoader.generateCacheKey(currentPlace.identifier)
        currentPlace.cacheID = DataLoader.generateCacheKey(currentPlace.identifier)
        dbgprint("cacheKey for " + currentPlace.identifier + " is: " + currentPlace.cacheID)
        cacheData.alreadyLoadedFromCache = false

        var ok = loadFromCache()
        dbgprint("CACHE " + ok)
        if (!ok) {
            loadDataFromInternet()
        }
    }

    function loadDataFromInternet() {
        dbgprint2("loadDataFromInternet")

        if (loadingData.loadingDatainProgress) {
            dbgprint("still loading")
            return
        }
        loadingDataComplete = false
        loadingData.loadingDatainProgress = true
        loadingData.lastloadingStartTime = dateNow()
        loadingData.nextReload = -1
        currentPlace.provider = setCurrentProviderAccordingId(currentPlace.providerId)
        currentPlace.creditLink = currentPlace.provider.getCreditLink(currentPlace.identifier)
        currentPlace.creditLabel = currentPlace.provider.getCreditLabel(currentPlace.identifier)
        loadingData.loadingXhrs = currentPlace.provider.loadDataFromInternet(
                    dataLoadedFromInternet,
                    reloadDataFailureCallback,
                    { placeIdentifier: currentPlace.identifier, timezoneID: currentPlace.timezoneID })
    }

    function dataLoadedFromInternet() {
        dbgprint2("dataLoadedFromInternet")
        dbgprint("Data Loaded From Internet successfully")

        loadingData.lastloadingSuccessTime = dateNow()
        loadingData.loadingDatainProgress = false
        loadingData.nextReload = dateNow() + timerData.reloadIntervalMs
        loadingData.failedAttemptCount = 0
        currentPlace.nextReload = dateNow() + timerData.reloadIntervalMs
        dbgprint(dateNow() + " + " +  timerData.reloadIntervalMs + " = " + loadingData.nextReload)

        nextDaysCount = nextDaysModel.count

        updateLastReloadedText()
        updateCompactItem()
        refreshTooltipSubText()
        dbgprint("meteogramModelChanged:" + meteogramModelChanged)
        meteogramModelChanged = !meteogramModelChanged
        dbgprint("meteogramModelChanged:" + meteogramModelChanged)

        saveToCache()
        
        // === ATMOSPHERIC EFFECTS UPDATE ===
        if (atmosphericEffectsEnabled) {
            // Update wind direction for particle effects
            if (actualWeatherModel.count > 0) {
                weatherEffectsContainer.windDirection = actualWeatherModel.get(0).windDirection || 0
            }
            
            // Trigger wallpaper update if enabled
            if (dynamicWallpaperEnabled) {
                wallpaperController.applyWallpaperWithBrightness()
            }
        }
    }

    function reloadDataFailureCallback() {
        dbgprint("Failed to Load Data successfully")
        cacheData.loadingDatainProgress = false
        dbgprint("Error getting weather data. Scheduling data reload...")
        loadingData.nextReload = dateNow()
        loadFromCache()
    }

    function updateLastReloadedText() {
        dbgprint("updateLastReloadedText: " + loadingData.lastloadingSuccessTime)
        if (loadingData.lastloadingSuccessTime > 0) {
            lastReloadedText = '⬇ ' + DataLoader.getLastReloadedTimeText(dateNow() - loadingData.lastloadingSuccessTime)
        }
        plasmoid.status = DataLoader.getPlasmoidStatus(loadingData.lastloadingSuccessTime, inTrayActiveTimeoutSec)
        dbgprint(plasmoid.status)
    }

    function updateCompactItem(){
        dbgprint2("updateCompactItem")
        dbgprint(JSON.stringify(currentWeatherModel))
        let icon = currentWeatherModel.iconName
        iconNameStr = (icon > 0) ? IconTools.getIconCode(icon, currentPlace.providerId, currentWeatherModel.isDay) : '\uf07b'
        temperatureStr = currentWeatherModel.temperature !== 9999 ? UnitUtils.getTemperatureNumberExt(currentWeatherModel.temperature, temperatureType) : '--'
    }

    function refreshTooltipSubText() {
        dbgprint2("refreshTooltipSubText")
        if (currentWeatherModel === undefined || currentWeatherModel.nearFutureWeather.iconName === null || currentWeatherModel.count === 0) {
            dbgprint("model not yet ready")
            return
        }

        var nearFutureWeather = currentWeatherModel.nearFutureWeather
        var futureWeatherIcon = IconTools.getIconCode(nearFutureWeather.iconName, currentPlace.providerId, (currentWeatherModel.isDay ? 1 : 0))
        var wind1=Math.round(currentWeatherModel.windDirection)
        var windDirectionIcon = IconTools.getWindDirectionIconCode(wind1)
        var lastReloadedSubText = lastReloadedText
        var subText = ""
        subText += "<br /><br /><font size=\"4\" style=\"font-family: weathericons;\">" + windDirectionIcon + "</font><font size=\"4\"> " + wind1 + "\u00B0 &nbsp; @ " + UnitUtils.getWindSpeedText(currentWeatherModel.windSpeedMps, windSpeedType) + "</font>"
        subText += "<br /><font size=\"4\">" + UnitUtils.getPressureText(currentWeatherModel.pressureHpa, pressureType) + "</font>"
        
        // === ENHANCED TOOLTIP WITH FEELS LIKE ===
        if (feelsLikeTooltipEnabled && atmosphericEffectsEnabled) {
            subText += "<br /><font size=\"4\">Feels like " + feelsLikeTemp + "° (" + comfortLevel + ", " + weatherMood + ")</font>"
        }
        
        subText += "<br /><table>"
        if ((currentWeatherModel.humidity !== undefined) && (currentWeatherModel.cloudiness !== undefined)) {
            subText += "<tr>"
            subText += "<td><font size=\"4\"><font style=\"font-family: weathericons\">\uf07a</font>&nbsp;" + currentWeatherModel.humidity + "%</font></td>"
            subText += "<td><font size=\"4\"><font style=\"font-family: weathericons\">\uf013</font>&nbsp;" + currentWeatherModel.cloudiness + "%</font></td>"
            subText += "</tr>"
            subText += "<tr><td>&nbsp;</td><td></td></tr>"
        }
        subText += "<tr>"
        let tzName = "GMT"
        if (timezoneType === 0) { tzName = getLocalTimeZone() }
        if (timezoneType === 1) { tzName = "GMT" }
        if (timezoneType === 2) { tzName = currentPlace.timezoneShortName }
        subText += "<td><font size=\"4\"><font style=\"font-family: weathericons\">\uf051</font>&nbsp;" + currentWeatherModel.sunRiseTime + " " + tzName + "&nbsp;&nbsp;&nbsp;</font></td>"
        subText += "</tr>"
        subText += "<tr>"
        subText += "<td><font size=\"4\"><font style=\"font-family: weathericons\">\uf052</font>&nbsp;" + currentWeatherModel.sunSetTime + " " + tzName + "</font></td>"
        subText += "</tr>"
        subText += "</table>"

        subText += "<br /><br />"
        subText += "<font size=\"3\">" + i18n("near future") + ":" + "</font>"
        subText += "<b>"
        subText += "<font size=\"6\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" + UnitUtils.getTemperatureNumber(nearFutureWeather.temperature, temperatureType) + "°"
        subText += "&nbsp;&nbsp;<font style=\"font-family: weathericons\">" + futureWeatherIcon + "</font></font>"
        subText += "</b>"
        toolTipMainText = currentPlace.alias
        toolTipSubText = lastReloadedText + subText
    }

    Component.onCompleted: {
        dbgprint2("MAIN.QML WITH ATMOSPHERIC EFFECTS")

        if (plasmoid.configuration.firstRun) {
            let URL =  Qt.resolvedUrl("../code/db/GI.csv")
            var xhr = new XMLHttpRequest()
            xhr.timeout = loadingData.loadingDataTimeoutMs;
            dbgprint('Test local file opening - url: ' + URL)
            xhr.open('GET', URL)
            xhr.setRequestHeader("User-Agent","Mozilla/5.0 (X11; Linux x86_64) Gecko/20100101 ")
            xhr.send()
            xhr.onload =  (event) => {
                dbgprint("env_QML_XHR_ALLOW_FILE_READ = 1. Using Builtin Location databases...")
                env_QML_XHR_ALLOW_FILE_READ = true
            }

            if (plasmoid.configuration.widgetFontSize === undefined) {
                plasmoid.configuration.widgetFontSize = 30
                widgetFontSize = 20
            }

            switch (Qt.locale().measurementSystem) {
            case (Locale.MetricSystem):
                plasmoid.configuration.temperatureType = 0
                plasmoid.configuration.pressureType = 0
                plasmoid.configuration.windSpeedType = 2
                break;
            case (Locale.ImperialUSSystem):
                plasmoid.configuration.temperatureType = 1
                plasmoid.configuration.pressureType = 1
                plasmoid.configuration.windSpeedType = 1
                break;
            case (Locale.ImperialUKSystem):
                plasmoid.configuration.temperatureType = 0
                plasmoid.configuration.pressureType = 0
                plasmoid.configuration.windSpeedType = 1
                break;
            }
            
            // === ATMOSPHERIC EFFECTS DEFAULTS ===
            if (plasmoid.configuration.atmosphericEffectsEnabled === undefined) {
                plasmoid.configuration.atmosphericEffectsEnabled = true
            }
            if (plasmoid.configuration.particleEffectsEnabled === undefined) {
                plasmoid.configuration.particleEffectsEnabled = true
            }
            if (plasmoid.configuration.dynamicWallpaperEnabled === undefined) {
                plasmoid.configuration.dynamicWallpaperEnabled = false // Conservative default
            }
            if (plasmoid.configuration.soundEffectsEnabled === undefined) {
                plasmoid.configuration.soundEffectsEnabled = false
            }
            if (plasmoid.configuration.feelsLikeTooltipEnabled === undefined) {
                plasmoid.configuration.feelsLikeTooltipEnabled = true
            }
            
            plasmoid.configuration.firstRun = false
        }
        timerData.reloadIntervalMin=plasmoid.configuration.reloadIntervalMin
        timerData.reloadIntervalMs=timerData.reloadIntervalMin * 60000

        dbgprint("plasmoid.formFactor:" + plasmoid.formFactor)
        dbgprint("plasmoid.location:" + plasmoid.location)
        dbgprint("plasmoid.configuration.layoutType:" + plasmoid.configuration.layoutType)
        dbgprint("plasmoid.containment.containmentType:" + plasmoid.containment.containmentType)
        if (inTray) {
            dbgprint("IN TRAY!")
        }

        // === ATMOSPHERIC EFFECTS INITIALIZATION ===
        if (atmosphericEffectsEnabled) {
            dbgprint("Atmospheric effects enabled")
        }

        dbgprint2(" Load Cache")
        var cacheContent = weatherCache.readCache()

        dbgprint("readCache result length: " + cacheContent.length)

        // fill cache
        if (cacheContent) {
            try {
                cacheData.cacheMap = JSON.parse(cacheContent)
                dbgprint("cacheMap initialized - keys:")
                for (var key in cacheData.cacheMap) {
                    dbgprint("  " + key + ", data: " + cacheData.cacheMap[key])
                }
            } catch (error) {
                dbgprint("error parsing cacheContent")
            }
        }
        cacheData.cacheMap = cacheData.cacheMap || {}

        dbgprint2("get Default Place")
        setNextPlace(true)
    }

    onTimezoneTypeChanged: {
        if (currentPlace.identifier !== "") {
            dbgprint2('timezoneType changed')
            cacheData.cacheKey = DataLoader.generateCacheKey(currentPlace.identifier)
            currentPlace.cacheID = DataLoader.generateCacheKey(currentPlace.identifier)
            dbgprint("cacheKey for " + currentPlace.identifier + " is: " + currentPlace.cacheID)
            cacheData.alreadyLoadedFromCache = false
            loadDataFromInternet()
            meteogramModelChanged = ! meteogramModelChanged
        }
    }

    function loadFromCache() {
        dbgprint2("loadFromCache")
        dbgprint('loading from cache, config key: ' + cacheData.cacheKey)

        if (cacheData.alreadyLoadedFromCache) {
            dbgprint('already loaded from cache')
            return true
        }
        if (!cacheData.cacheMap || !cacheData.cacheMap[cacheData.cacheKey]) {
            dbgprint('cache not available')
            return false
        }

        currentPlace = JSON.parse(cacheData.cacheMap[cacheData.cacheKey][1])
        currentPlace.provider = setCurrentProviderAccordingId(currentPlace.providerId)

        currentWeatherModel = cacheData.cacheMap[cacheData.cacheKey][2]
        let meteogramModelData = JSON.parse( cacheData.cacheMap[cacheData.cacheKey][3])
        let nextDaysModelData = JSON.parse( cacheData.cacheMap[cacheData.cacheKey][4])
        
        meteogramModel.clear()
        for (var i = 0; i < meteogramModelData.length; ++i) {
            meteogramModelData[i]['from'] = new Date(Date.parse(meteogramModelData[i]['from']))
            meteogramModelData[i]['to'] = new Date(Date.parse(meteogramModelData[i]['to']))
            meteogramModel.append(meteogramModelData[i])
        }

        nextDaysModel.clear()
        for (var i = 0; i < nextDaysModelData.length; ++i) {
            nextDaysModel.append(nextDaysModelData[i])
        }
        dbgprint(nextDaysModelData.length)
        nextDaysCount = nextDaysModel.count

        updateCompactItem()
        refreshTooltipSubText()
        dbgprint("meteogramModelChanged:" + meteogramModelChanged)
        meteogramModelChanged = !meteogramModelChanged
        dbgprint("meteogramModelChanged:" + meteogramModelChanged)

        return true
    }

    function saveToCache() {
        dbgprint2("saveCache")
        dbgprint(currentPlace.alias)
        let cacheID = currentPlace.cacheID

        var meteogramModelData = ([])
        for (var i = 0; i < meteogramModel.count; ++i) {
            meteogramModelData.push(meteogramModel.get(i))
        }

        var nextDayModelData = ([])
        for (i = 0; i < nextDaysModel.count; ++i) {
            nextDayModelData.push(nextDaysModel.get(i))
        }
        currentPlace.provider = ""

        let contentToCache = {1: JSON.stringify(currentPlace), 2: currentWeatherModel, 3: JSON.stringify(meteogramModelData), 4: JSON.stringify(nextDayModelData)}
        print("saving cacheKey = " + cacheID)
        cacheData.cacheMap[cacheID] = contentToCache
    }

    Timer {
        interval: 10000
        running: true
        repeat: true
        onTriggered: {
            dbgprint2("Timer Triggered")
            var now=dateNow()
            dbgprint("*** loadingData Flag : " + loadingData.loadingDatainProgress)
            dbgprint("*** loadingData failedAttemptCount : " + loadingData.failedAttemptCount)
            dbgprint("*** Last Load Success: " + (loadingData.lastloadingSuccessTime))
            dbgprint("*** Next Load Due    : " + (currentPlace.nextReload))
            dbgprint("*** Time Now         : " + now)
            dbgprint("*** Next Load in     : " + Math.round((currentPlace.nextReload - now) / 1000) + " sec = "+ ((currentPlace.nextReload - now) / 60000).toFixed(2) + " min")

            updateLastReloadedText()

            if (loadingData.loadingDatainProgress) {
                dbgprint("Timeout in:" + (loadingData.lastloadingStartTime + loadingData.loadingDataTimeoutMs - now))
                if (now > (loadingData.lastloadingStartTime + loadingData.loadingDataTimeoutMs)) {
                    loadingData.failedAttemptCount++
                    let retryTime = Math.min(loadingData.failedAttemptCount, 30) * 30
                    console.log("Timed out downloading weather data - aborting attempt. Retrying in " + retryTime  +" seconds time.")
                    loadingData.loadingDatainProgress = false
                    loadingData.lastloadingSuccessTime = 0
                    currentPlace.nextReload = now + (retryTime * 1000)
                    loadingDataComplete = true
                }
            } else {
                if (now > currentPlace.nextReload) {
                    loadDataFromInternet()
                }
            }

            // === ATMOSPHERIC EFFECTS TIMER UPDATES ===
            if (atmosphericEffectsEnabled && !loadingData.loadingDatainProgress) {
                // Update wind direction for particle effects
                if (actualWeatherModel.count > 0) {
                    var newWindDirection = actualWeatherModel.get(0).windDirection || 0
                    if (weatherEffectsContainer.windDirection !== newWindDirection) {
                        weatherEffectsContainer.windDirection = newWindDirection
                    }
                }
                
                // Update wallpaper on time changes (every minute check)
                if (dynamicWallpaperEnabled && now % 60000 < 10000) {
                    wallpaperController.applyWallpaperWithBrightness()
                }
            }
        }
    }
}