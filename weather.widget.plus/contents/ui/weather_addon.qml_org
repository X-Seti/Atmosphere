    // X-Seti July 14 - 2025

    function updateAdditionalWeatherInfoText() {
        if (additionalWeatherInfo === undefined || additionalWeatherInfo.nearFutureWeather.iconName === null || meteogramModel.count === 0) {
            dbgprint('model not yet ready')
            return
        }

        // Update sunrise/sunset times if available
        if (hasSunData) {
            additionalWeatherInfo.sunRise = localSunrise
            additionalWeatherInfo.sunSet = localSunset
        }

        var sunRise = UnitUtils.convertDate(additionalWeatherInfo.sunRise, timezoneType, timezoneOffset)
        var sunSet = UnitUtils.convertDate(additionalWeatherInfo.sunSet, timezoneType, timezoneOffset)
        additionalWeatherInfo.sunRiseTime = Qt.formatTime(sunRise, Qt.locale().timeFormat(Locale.ShortFormat))
        additionalWeatherInfo.sunSetTime = Qt.formatTime(sunSet, Qt.locale().timeFormat(Locale.ShortFormat))

        var nearFutureWeather = additionalWeatherInfo.nearFutureWeather
        var futureWeatherIcon = IconTools.getIconCode(nearFutureWeather.iconName, currentProvider.providerId, getPartOfDayIndex())
        var wind1 = Math.round(meteogramModel.get(0).windDirection)
        var windDirectionIcon = IconTools.getWindDirectionIconCode(wind1)
        var subText = ''
        subText += '<br /><font size="4" style="font-family: weathericons;">' + windDirectionIcon + '</font><font size="4"> ' + wind1 + '\u00B0 &nbsp; @ ' + UnitUtils.getWindSpeedText(meteogramModel.get(0).windSpeedMps, windSpeedType) + '</font>'
        subText += '<br /><font size="4">' + UnitUtils.getPressureText(meteogramModel.get(0).pressureHpa, pressureType) + '</font>'
        subText += '<br /><table>'
        if ((meteogramModel.get(0).humidity !== undefined) && (meteogramModel.get(0).cloudiness !== undefined)) {
            subText += '<tr>'
            subText += '<td><font size="4"><font style="font-family: weathericons">\uf07a</font>&nbsp;' + meteogramModel.get(0).humidity + '%</font></td>'
            subText += '<td><font size="4"><font style="font-family: weathericons">\uf013</font>&nbsp;' + meteogramModel.get(0).cloudiness + '%</font></td>'
            subText += '</tr>'
            subText += '<tr><td>&nbsp;</td><td></td></tr>'
        }
        subText += '<tr>'
        subText += '<td><font size="4"><font style="font-family: weathericons">\uf051</font>&nbsp;' + additionalWeatherInfo.sunRiseTime + ' '+timezoneShortName + '&nbsp;&nbsp;&nbsp;</font></td>'
        subText += '<td><font size="4"><font style="font-family: weathericons">\uf052</font>&nbsp;' + additionalWeatherInfo.sunSetTime + ' '+timezoneShortName + '</font></td>'
        subText += '</tr>'
        subText += '</table>'

        subText += '<br /><br />'
        subText += '<font size="3">' + i18n("near future") + '</font>'
        subText += '<b>'
        subText += '<font size="6">&nbsp;&nbsp;&nbsp;' + UnitUtils.getTemperatureNumber(nearFutureWeather.temperature, temperatureType) + UnitUtils.getTemperatureEnding(temperatureType)
        subText += '&nbsp;&nbsp;&nbsp;<font style="font-family: weathericons">' + futureWeatherIcon + '</font></font>'
        subText += '</b>'
        tooltipSubText = subText
    }

    function refreshTooltipSubText() {
        dbgprint('refreshing sub text')
        if (additionalWeatherInfo === undefined || additionalWeatherInfo.nearFutureWeather.iconName === null || meteogramModel.count === 0) {
            dbgprint('model not yet ready')
            return
        }
        updateAdditionalWeatherInfoText()
        var nearFutureWeather = additionalWeatherInfo.nearFutureWeather
        var futureWeatherIcon = IconTools.getIconCode(nearFutureWeather.iconName, currentProvider.providerId, getPartOfDayIndex())
        var wind1=Math.round(meteogramModel.get(0).windDirection)
        var windDirectionIcon = IconTools.getWindDirectionIconCode(wind1)
        var subText = ''
        subText += '<br /><font size="4" style="font-family: weathericons;">' + windDirectionIcon + '</font><font size="4"> ' + wind1 + '\u00B0 &nbsp; @ ' + UnitUtils.getWindSpeedText(meteogramModel.get(0).windSpeedMps, windSpeedType) + '</font>'
        subText += '<br /><font size="4">' + UnitUtils.getPressureText(meteogramModel.get(0).pressureHpa, pressureType) + '</font>'
        subText += '<br /><table>'
        if ((meteogramModel.get(0).humidity !== undefined) && (meteogramModel.get(0).cloudiness !== undefined)) {
            subText += '<tr>'
            subText += '<td><font size="4"><font style="font-family: weathericons">\uf07a</font>&nbsp;' + meteogramModel.get(0).humidity + '%</font></td>'
            subText += '<td><font size="4"><font style="font-family: weathericons">\uf013</font>&nbsp;' + meteogramModel.get(0).cloudiness + '%</font></td>'
            subText += '</tr>'
            subText += '<tr><td>&nbsp;</td><td></td></tr>'
        }
        subText += '<tr>'
        subText += '<td><font size="4"><font style="font-family: weathericons">\uf051</font>&nbsp;' + additionalWeatherInfo.sunRiseTime + ' '+timezoneShortName + '&nbsp;&nbsp;&nbsp;</font></td>'
        subText += '<td><font size="4"><font style="font-family: weathericons">\uf052</font>&nbsp;' + additionalWeatherInfo.sunSetTime + ' '+timezoneShortName + '</font></td>'
        subText += '</tr>'
        subText += '</table>'

        subText += '<br /><br />'
        subText += '<font size="3">' + i18n("near future") + '</font>'
        subText += '<b>'
        subText += '<font size="6">&nbsp;&nbsp;&nbsp;' + UnitUtils.getTemperatureNumber(nearFutureWeather.temperature, temperatureType) + UnitUtils.getTemperatureEnding(temperatureType)
        subText += '&nbsp;&nbsp;&nbsp;<font style="font-family: weathericons">' + futureWeatherIcon + '</font></font>'
        subText += '</b>'
        tooltipSubText = subText
    }

    function getPartOfDayIndex() {
        var now = new Date().getTime()
        let sunrise1 = additionalWeatherInfo.sunRise.getTime()
        let sunset1 = additionalWeatherInfo.sunSet.getTime()
        let icon = ((now > sunrise1) && (now < sunset1)) ? 0 : 1
        // setDebugFlag(true)
        dbgprint(JSON.stringify(additionalWeatherInfo))
        dbgprint("NOW = " + now + "\tSunrise = " + sunrise1 + "\tSunset = " + sunset1 + "\t" + (icon === 0 ? "isDay" : "isNight"))
        dbgprint("\t > Sunrise:" + (now > sunrise1) + "\t\t Sunset:" + (now < sunset1))
        // setDebugFlag(false)

        return icon
    }

    function abortTooLongConnection(forceAbort) {
        if (!loadingData) {
            return
        }
        if (forceAbort) {
            dbgprint('timeout reached, aborting existing xhrs')
            loadingXhrs.forEach(function (xhr) {
                xhr.abort()
            })
            reloadDataFailureCallback()
        } else {
            dbgprint('regular loading, no aborting yet')
            return
        }
    }

    function tryReload() {
        updateLastReloadedText()

        if (updatingPaused) {
            return
        }

        reloadData()
    }

    Timer {
        interval: 10000
        running: true
        repeat: true
        onTriggered: {
            var now=dateNow()
            dbgprint("*** Timer triggered")
            dbgprint("*** loadingData Flag : " + loadingData)
            dbgprint("*** Last Load Success: " + (lastloadingSuccessTime))
            dbgprint("*** Next Load Due    : " + (nextReload))
            dbgprint("*** Time Now         : " + now)
            dbgprint("*** Next Load in     : " + Math.round((nextReload - now) / 1000) + " sec = "+ ((nextReload - now) / 60000).toFixed(2) + " min")

            updateLastReloadedText()
            if ((lastloadingSuccessTime===0) && (updatingPaused)) {
                toggleUpdatingPaused()
            }

            if (loadingData) {
                dbgprint("Timeout in:" + (lastloadingStartTime + loadingDataTimeoutMs - now))
                if (now > (lastloadingStartTime + loadingDataTimeoutMs)) {
                    console.log("Timed out downloading weather data - aborting attempt. Retrying in 60 seconds time.")
                    abortTooLongConnection(true)
                    nextReload=now + 60000
                }
            } else {
                if (now > nextReload) {
                    tryReload()
                }
            }
        }
    }

    onTemperatureTypeChanged: {
        refreshTooltipSubText()
    }

    onPressureTypeChanged: {
        refreshTooltipSubText()
    }

    onWindSpeedTypeChanged: {
        refreshTooltipSubText()
    }

    onTwelveHourClockEnabledChanged: {
        refreshTooltipSubText()
    }

    onTimezoneTypeChanged: {
        if (lastloadingSuccessTime > 0) {
            refreshTooltipSubText()
        }
    }

    function dbgprint(msg) {
        if (!debugLogging) {
            return
        }
        print('[weatherWidget] ' + msg)
    }

    function dateNow() {
        var now=new Date().getTime()
        return now
    }

    function setDebugFlag(flag) {
        debugLogging = flag
    }

    function getLocalTimeZone() {
        return dataSource.data["Local"]["Timezone Abbreviation"]
    }

    // === HOVER FEELS LIKE TOOLTIP ===
    Item {
        id: feelsLikeTooltip
        width: 180
        height: 80
        visible: false
        z: 2000 // Always on top
        opacity: 0
        property real targetX: 0
        property real targetY: 0

        // Background with subtle blur
        Rectangle {
            anchors.fill: parent
            color: textColorLight ? "#111111" : "#eeeeee"
            radius: 12
            border.color: textColorLight ? "#333333" : "#dddddd"
            border.width: 1
            opacity: 0.95

            // Subtle inner glow for depth
            Rectangle {
                anchors.fill: parent
                anchors.margins: 1
                color: "transparent"
                border.color: textColorLight ? "rgba(255,255,255,0.1)" : "rgba(0,0,0,0.1)"
                border.width: 1
                radius: 11
            }
        }

        // Text content
        Column {
            anchors.centerIn: parent
            spacing: 2
            Text {
                text: i18n("Feels like %1°", atmosphereWidget.feelsLikeTemp)
                font.pixelSize: widgetFontSize * 0.75
                color: textColorLight ? "#ffffff" : "#111111"
                font.bold: true
            }
            Text {
                text: atmosphereWidget.comfortLevel + " • " + atmosphereWidget.weatherMood
                font.pixelSize: widgetFontSize * 0.65
                color: textColorLight ? "#cccccc" : "#555555"
            }
        }

        // Animation: Fade in/out
        Behavior on opacity {
            NumberAnimation {
                duration: 200
                easing.type: Easing.InOutQuad
            }
        }

        // Position: Centered above the temperature display
        x: atmosphereWidget.temperatureLabel.x + (atmosphereWidget.temperatureLabel.width - width) / 2
        y: atmosphereWidget.temperatureLabel.y - height - 10

        // Hide by default
        Component.onCompleted: {
            visible = false
            opacity = 0
        }
    }

    // --- MOUSE AREA TO TRIGGER TOOLTIP ---
    MouseArea {
        id: tempHoverArea
        anchors.fill: temperatureLabel // <-- This assumes your main temp label is named 'temperatureLabel'
        hoverEnabled: true
        acceptedButtons: Qt.NoButton

        onEntered: {
            feelsLikeTooltip.visible = true
            feelsLikeTooltip.opacity = 1
        }

        onExited: {
            feelsLikeTooltip.opacity = 0
            setTimeout(function() {
                feelsLikeTooltip.visible = false
            }, 250)
        }
    }
    // === ATMOSPHERE WIDGET (ALL-IN-ONE) ===
    Item {
        id: atmosphereWidget
        anchors.fill: parent
        z: 1002 // Highest layer — above everything

        // --- SOUND EFFECTS ---
        property bool soundEnabled: plasmoid.configuration.soundEffectsEnabled !== false
        property string soundDir: "qrc:/sounds/"

        SoundEffect {
            id: hourlyDing
            source: soundDir + "ding.mp3"
            volume: 0.3
            enabled: atmosphereWidget.soundEnabled
        }

        SoundEffect {
            id: windWhoosh
            source: soundDir + "wind.mp3"
            volume: 0.2
            enabled: atmosphereWidget.soundEnabled
        }

        SoundEffect {
            id: rainPatter
            source: soundDir + "rain.mp3"
            volume: 0.25
            enabled: atmosphereWidget.soundEnabled
        }

        SoundEffect {
            id: snowCrunch
            source: soundDir + "snow.mp3"
            volume: 0.2
            enabled: atmosphereWidget.soundEnabled
        }

        // --- WALLPAPER PATHS (USE YOUR EXACT PATHS) ---
        property string morningWallpaper: "/home/x2/Wallpapers/System-Defaults/fruitdark.jpg"
        property string afternoonWallpaper: "/home/x2/Wallpapers/System-Defaults/fruit.jpg"
        property string eveningWallpaper: "/home/x2/Wallpapers/System-Defaults/fruitdarker.jpg"
        property string nightWallpaper: "/home/x2/Wallpapers/System-Defaults/fruitdarkest.jpg"

        // --- BASE IMAGE FOR BRIGHTNESS ADJUSTMENT ---
        property string baseWallpaper: afternoonWallpaper // Use brightest as base for modulate

        // --- CALCULATE TIME-BASED WALLPAPER ---

        property string selectedWallpaper: {
            var now = new Date().getTime()
            var useSun = plasmoid.configuration.useSunriseSunset && hasSunData

            if (useSun && localSunrise.getTime() > 0 && localSunset.getTime() > 0) {
                var sunrise = localSunrise.getTime()
                var sunset = localSunset.getTime()

                // Morning: 1 hour before sunrise → 1 hour after sunrise
                if (now > sunrise - 3600000 && now < sunrise + 3600000) return morningWallpaper
                    // Day: between sunrise + 1h and sunset - 1h
                    else if (now > sunrise + 3600000 && now < sunset - 3600000) return afternoonWallpaper
                        // Evening: 1 hour before sunset → 1 hour after sunset
                        else if (now > sunset - 3600000 && now < sunset + 3600000) return eveningWallpaper
                            // Night: everything else
                            else return nightWallpaper
            }

            // Fallback to time-based if API fails or disabled
            var hour = new Date().getHours()
            if (hour >= 6 && hour < 12) return morningWallpaper
                else if (hour >= 12 && hour < 17) return afternoonWallpaper
                    else if (hour >= 17 && hour < 20) return eveningWallpaper
                        else return nightWallpaper
        }

        // --- CALCULATE BRIGHTNESS (TIME + WEATHER) ---
        property real calculatedBrightness: {
            var now = new Date().getTime()
            var useSun = plasmoid.configuration.useSunriseSunset && hasSunData

            if (useSun && localSunrise.getTime() > 0 && localSunset.getTime() > 0) {
                var sunrise = localSunrise.getTime()
                var sunset = localSunset.getTime()
                var dayLength = sunset - sunrise
                var timeSinceSunrise = now - sunrise

                if (timeSinceSunrise < 0) return 20  // Before sunrise
                    if (timeSinceSunrise > dayLength) return 20  // After sunset

                        // Linear interpolation: darkest at sunrise/sunset, brightest at noon
                        var progress = Math.max(0, Math.min(1, timeSinceSunrise / dayLength))
                        var base = 100 * (1 - Math.abs(progress - 0.5) * 2) // Triangle wave: peaks at noon
                        return Math.round(base)
            }

            // Fallback to time-based brightness (from your original script)
            var hour = new Date().getHours()
            var brightness_levels = {
                0: 20, 1: 30, 2: 35, 3: 40, 4: 45, 5: 50,
                6: 60, 7: 70, 8: 80, 9: 85, 10: 90, 11: 95,
                12: 100, 13: 100, 14: 95, 15: 90, 16: 85, 17: 80,
                18: 70, 19: 60, 20: 50, 21: 40, 22: 30, 23: 25
            }
            var base = brightness_levels[hour] || 40

            // Weather adjustment
            var cond = currentProvider ? currentProvider.currentCondition.toLowerCase() : ""
            var weatherAdj = 0
            if (cond.includes("snow")) weatherAdj = 15
                else if (cond.includes("sun") || cond.includes("clear")) weatherAdj = 10
                    else if (cond.includes("rain") || cond.includes("drizzle")) weatherAdj = -20
                        else if (cond.includes("cloudy") || cond.includes("overcast")) weatherAdj = -15

                            return Math.max(15, Math.min(100, base + weatherAdj))
        }

        // --- WALLPAPER ADJUSTMENT FUNCTION ---
        function applyWallpaperWithBrightness() {
            var path = selectedWallpaper
            if (!Qt.canOpenFile(path)) {
                console.warn("Wallpaper not found:", path)
                return
            }

            var tempPath = Qt.resolvedUrl("file:///tmp/plasma-adjusted-wallpaper-" + plasmoid.id + ".jpg")

            if (calculatedBrightness === 100) {
                setPlasmaWallpaper(path)
            } else {
                var cmd = "convert \"" + path + "\" -modulate 100," + calculatedBrightness + ",100 \"" + tempPath + "\""
                var process = new QtObject()
                process.execute = function(command) {
                    var result = Qt.runCommand(command)
                    return result
                }
                process.execute(cmd)

                setTimeout(function() {
                    if (Qt.fileExists(tempPath)) {
                        setPlasmaWallpaper(tempPath)
                    } else {
                        setPlasmaWallpaper(path)
                    }
                }, 1000)
            }
        }

        // --- SET WALLPAPER VIA DBUS ---
        function setPlasmaWallpaper(path) {
            if (!path) return;

                var escapedPath = path.replace(/"/g, '\\"')
                var script = `
                var allDesktops = desktops();
            for (i=0; i<allDesktops.length; i++) {
                d = allDesktops[i];
                d.wallpaperPlugin = 'org.kde.image';
                d.currentConfigGroup = Array('Wallpaper', 'org.kde.image', 'General');
                d.writeConfig('Image', 'file://${escapedPath}');
            }
            `

            try {
                var cmd = "qdbus org.kde.plasmashell /PlasmaShell org.kde.PlasmaShell.evaluateScript \"" + script + "\""
                executable.exec(cmd)
                console.log("Wallpaper updated:", path, "brightness:", calculatedBrightness)
            } catch (e) {
                console.error("DBus wallpaper error:", e.message)
            }
        }

        // --- SUN GLINT (GENTLE HIGHLIGHT ON SUNNY DAYS) ---
        Item {
            id: sunGlint
            width: 40
            height: 40
            radius: 20
            color: "white"
            opacity: 0
            z: 1003
            anchors.horizontalCenter: parent.horizontalCenter
            anchors.top: parent.top
            visible: !currentProvider ? false : (
                !currentProvider.currentCondition.toLowerCase().includes("cloud") &&
                !currentProvider.currentCondition.toLowerCase().includes("rain") &&
                !currentProvider.currentCondition.toLowerCase().includes("snow") &&
                calculatedBrightness > 85
            )

            Behavior on opacity { NumberAnimation { duration: 1500 } }

            SequentialAnimation on x {
                loops: Animation.Infinite
                running: visible
                PropertyAnimation { to: parent.width / 2 - 20; duration: 4000 }
                PropertyAnimation { to: parent.width / 2 + 20; duration: 4000 }
            }

            Timer {
                interval: 3000
                repeat: true
                running: visible
                onTriggered: {
                    opacity = 0.9
                    setTimeout(() => opacity = 0, 600)
                }
            }
        }

        // --- RAIN AND SNOW PARTICLES WITH WIND ALIGNMENT ---
        property real windDirection: meteogramModel.count > 0 ? meteogramModel.get(0).windDirection : 0

        Item {
            id: rainContainer
            anchors.fill: parent
            rotation: windDirection - 90
            visible: currentProvider && (
                currentProvider.currentCondition.toLowerCase().includes("rain") ||
                currentProvider.currentCondition.toLowerCase().includes("drizzle")
            )

            ParticleSystem {
                id: rainSystem
                width: parent.width
                height: parent.height

                ImageParticle {
                    source: "qrc:/effects/samples.webp"
                    colorVariation: 0.1
                    alpha: 0.7
                    size: 8
                    sizeVariation: 3
                    lifeSpan: 1500
                    velocityFromAngle: 90
                    velocityFromMagnitude: 110 + (meteogramModel.count > 0 ? meteogramModel.get(0).windSpeedMps * 8 : 0)
                    velocityVariation: 30
                }

                Emitter {
                    anchors.fill: parent
                    emitRate: 150
                    lifeSpan: 1500
                    lifeSpanVariation: 200
                }
            }
        }

        Item {
            id: snowContainer
            anchors.fill: parent
            rotation: windDirection - 90
            visible: currentProvider && (
                currentProvider.currentCondition.toLowerCase().includes("snow") ||
                currentProvider.currentCondition.toLowerCase().includes("sleet")
            )

            ParticleSystem {
                id: snowSystem
                width: parent.width
                height: parent.height

                ImageParticle {
                    source: "qrc:/effects/snowflake.svg"
                    color: "#ffffff"
                    alpha: 0.9
                    size: 12
                    sizeVariation: 4
                    lifeSpan: 4000
                    velocityFromAngle: 90
                    velocityFromMagnitude: 15 + (meteogramModel.count > 0 ? meteogramModel.get(0).windSpeedMps * 2 : 0)
                    velocityVariation: 30
                    rotationSpeed: 100
                    rotationSpeedVariation: 50
                }

                Emitter {
                    anchors.fill: parent
                    emitRate: 60
                    lifeSpan: 4000
                    lifeSpanVariation: 500
                }
            }
        }

        // --- DAY/NIGHT OVERLAY (SOFT DIMMING) ---
        Rectangle {
            id: lightingOverlay
            anchors.fill: parent
            color: "black"
            opacity: 0
            z: 1001

            Behavior on opacity {
                NumberAnimation {
                    duration: 3000
                    easing.type: Easing.InOutQuad
                }
            }

            opacity: {
                var cond = currentProvider ? currentProvider.currentCondition.toLowerCase() : ""
                var hour = new Date().getHours()

                if (cond.includes("snow")) return 0.5
                    else if (cond.includes("rain") || cond.includes("drizzle")) return 0.4
                        else if (cond.includes("cloudy") || cond.includes("overcast")) return 0.3
                            else if (hour >= 18 || hour < 6) return 0.6
                                else return 0.0
            }
        }

        // --- SOUND TRIGGERS ---
        function playSound(soundName) {
            if (!atmosphereWidget.soundEnabled) return;

                switch (soundName) {
                    case "ding": hourlyDing.play(); break
                    case "wind": windWhoosh.play(); break
                    case "rain": rainPatter.play(); break
                    case "snow": snowCrunch.play(); break
                }
        }


        // --- UPDATE LOGIC ---
        Component.onCompleted: {
            // Load sounds from resource if they exist
            var soundFiles = ["ding.mp3", "wind.mp3", "rain.mp3", "snow.mp3"]
            soundFiles.forEach(file => {
                if (!Qt.resourceExists(atmosphereWidget.soundDir + file)) {
                    console.warn("Sound file missing:", atmosphereWidget.soundDir + file)
                }
            })

            // Initial wallpaper update
            applyWallpaperWithBrightness()

            // Watch weather condition changes
            if (currentProvider) {
                currentProvider.onCurrentConditionChanged.connect(function() {
                    var cond = currentProvider.currentCondition.toLowerCase()
                    if (cond.includes("rain") && !rainContainer.visible) playSound("rain");
                    if (cond.includes("snow") && !snowContainer.visible) playSound("snow");
                        applyWallpaperWithBrightness();
                })
            }

            // Watch wind speed/direction changes
            meteogramModel.onDataChanged.connect(function() {
                if (meteogramModel.count > 0) {
                    windDirection = meteogramModel.get(0).windDirection
                    var windSpeed = meteogramModel.get(0).windSpeedMps
                    if (windSpeed > 7) {
                        playSound("wind")
                    }
                }
            })

            // Ensure we get initial wind direction
            if (meteogramModel.count > 0) {
                windDirection = meteogramModel.get(0).windDirection
            }
        }
    }

    Timer {
        interval: 10000
        running: true
        repeat: true
        onTriggered: {
            dbgprint2("Timer Triggered")
            var now=dateNow()
            dbgprint("*** loadingData Flag : " + loadingData.loadingDatainProgress)
            dbgprint("*** loadingData failedAttemptCount : " + loadingData.failedAttemptCount)
            dbgprint("*** Last Load Success: " + (loadingData.lastloadingSuccessTime))
            dbgprint("*** Next Load Due    : " + (currentPlace.nextReload))
            dbgprint("*** Time Now         : " + now)
            dbgprint("*** Next Load in     : " + Math.round((currentPlace.nextReload - now) / 1000) + " sec = "+ ((currentPlace.nextReload - now) / 60000).toFixed(2) + " min")

            updateLastReloadedText()
            // if ((loadingData.lastloadingSuccessTime === 0) && (updatingPaused)) {
                // currentPlace.nextReload=now + 60000()
            // }

            if (loadingData.loadingDatainProgress) {
                dbgprint("Timeout in:" + (loadingData.lastloadingStartTime + loadingData.loadingDataTimeoutMs - now))
                if (now > (loadingData.lastloadingStartTime + loadingData.loadingDataTimeoutMs)) {
                    loadingData.failedAttemptCount++
                    let retryTime = Math.min(loadingData.failedAttemptCount, 30) * 30
                    console.log("Timed out downloading weather data - aborting attempt. Retrying in " + retryTime  +" seconds time.")
                    loadingData.loadingDatainProgress = false
                    loadingData.lastloadingSuccessTime = 0
                    currentPlace.nextReload = now + (retryTime * 1000)
                    loadingDataComplete = true
                }
            } else {
                if (now > currentPlace.nextReload) {
                    loadDataFromInternet()
                }
            }
        }
    }
